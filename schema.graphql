type Factory @entity {
    id: ID! # Factory Address
    tokenCount: Int!
    exchanges: [Exchange!]! @derivedFrom(field: "factoryID")
}

type Exchange @entity {
    id: ID!                 # Exchange address
    tokenAddress: Bytes!
    factoryID: String!      # used for @derivedFrom of Factory
#   tokenSymbol: String, # There is no good way to do this, since not all contracts follow erc20.
}

# These are the top 6 exchanges, which are hard coded to be tracked in the subgraph manifest
type TrackedExchange @entity {
    id: ID!
    totalEth: BigInt!
    totalToken: BigInt!
    tokenAddress: Bytes!
    tokenTicker: String!
    totalUniToken: BigInt!
    totalUsers: Int!
    tokenHolders: [UserUniTokenBalance!]! @derivedFrom(field: "userAddress")
}

type User @entity {
    id: ID! # user eth adddress
    uniTokens: [UserUniTokenBalance!]!  @derivedFrom(field: "userAddress")
}

# Left out allowance for now
type UserUniTokenBalance @entity {
    id: ID!                     # ID is concatenation of token and addr. i.e. DAI-0xkashkd34....
    ethsDeposited: BigInt!
    tokensDeposited: BigInt!
    uniTokensOwned: BigInt!
    userAddress: Bytes!         # used for @derivedFrom of User
    tokenAddress: Bytes!        # used for @derivedFrom of TrackedExchange
}
