# Uniswap entity stores values from the Factory contract
type Uniswap @entity {
    id: ID! # Factory Address
    exchangeCount: Int!
    exchanges: [Exchange!]! @derivedFrom(field: "factoryID")

    # derived values
    totalVolume: BigDecimal
    totalDepositedLiquidity: BigDecimal
    totalRemovedLiquidity: BigDecimal
    totalVolumeUSD: BigDecimal                  # accumulate at each trade, not just calculated off whatever totalVolume is. making it more accurate for USD
    totalDepositedLiquidityUSD: BigDecimal
    totalRemovedLiquidityUSD: BigDecimal
    totalSwaps: BigInt
}

type Exchange @entity {
    id: ID!                                 # Uniswap Exchange address
    tokenAddress: Bytes!                    # Token address
    tokenSymbol: String!                    # TODO - change these from hardcoded when features exist
    tokenName: String!                      # TODO - change these from hardcoded when features exist
    tokenDecimals: Int!                     # TODO - change these from hardcoded when features exist
    fee: BigDecimal!
    version: Int!
    startTime: Int!                         # time exchange was created
    endTime: Int                            # Time exchange is closed (such as an upgrade to uniswap contacts)

    ethLiquidity: BigDecimal!               # In Eth, i.e. incorporates 10^-18 to get rid of pricing in wei
    tokenLiquidity: BigDecimal!             # must factor in the decimals of tokens, which can be various
    addLiquidityCount: BigInt!              # count the number of times liquidity has been added
    removeLiquidityCount: BigInt!           # count the number of times liquidity has been removed
    sellTokenCount: BigInt!                 # count the number of times the tokens been sold
    buyTokenCount: BigInt!                  # count the number of times the tokens been bought
    totalUniToken: BigInt!                  # Count of the unilying unitokens that represent ownership


    # Price values using eth
    lastPrice: BigDecimal!             # the last trade price
    price: BigDecimal!                      # price is the ratio of eth/token
    tradeVolume: BigDecimal!                # total tokens traded EVER
    totalValue: BigDecimal!                 # totalValue is accumulation of trade price X trade volume. TV = tokensSold * priceTokensSold
    weightedAvgPrice: BigDecimal!           # avg price of all trades since inception. WAP = totalValue / totalVolume

    # Price values uing usd TODO - get values from MKR usd oracle 
    lastPriceUSD: BigDecimal           # the last trade price
    priceUSD: BigDecimal!                   # USD / token
    tradeVolumeUSD: BigDecimal              # total tokens traded EVER
    totalValueUSD: BigDecimal               # totalValue is accumulation of trade price X trade volume. TV = tokensSold * priceTokensSold
    weightedAvgPriceUSD: BigDecimal         # avg price of all trades since inception. WAP = totalValue / totalVolume

    # Fields used to help derived relationship
    factoryID: String!                                                              # used for @derivedFrom of Factory
    tokenHolders: [UserExchangeData!]! @derivedFrom(field: "exchangeAddress")       # Relationship to show all token holders on the exchange
    txs: [Transaction!]! @derivedFrom(field: "exchangeAddress")                     # Relationship to show all txs on the exchange

}

type User @entity {
    id: ID! # user eth adddress
    exchangeBalances: [UserExchangeData!]!  @derivedFrom(field: "userAddress")
    txs: [Transaction!]!  @derivedFrom(field: "userAddress")
}

# Left out allowance for now, because handleApprove never gets called
type UserExchangeData @entity {
    id: ID!                     # ID is concatenation of token and user addr. i.e. DAI-0xkashkd34.... # TODO - handle multiple unknowns - they are probably overlapping right now
    userAddress: Bytes!         # used for @derivedFrom of User
    exchangeAddress: Bytes!        # used for @derivedFrom of TrackedExchange

    # Liquidity Provider Data
    ethDeposited: BigDecimal!      # where negative means eth was exchanged for tokens
    tokensDeposited: BigDecimal!    # where negative means tokens were exchanged for eth
    uniTokensMinted: BigInt!
    uniTokensBurned: BigInt!
    ethWithdrawn: BigDecimal!
    tokensWithdrawn: BigDecimal!
#    currentEthProfit: BigDecimal!      # NOT IMPLEMENTED - will add V2
#    currentTokenProfit: BigDecimal!    # NOT IMPLEMENTED - will add V2

    # Trading Data
    ethBought: BigDecimal!
    tokensBought: BigDecimal!
    totalEthFeesPaid: BigDecimal!
    totalTokenFeesPaid: BigDecimal!

    # TODO - Add in USD for the UserExchangebalance
}

type Transaction @entity {
    id: ID!             # Transaction Hash
    event: String!
    block: BigInt!
    timeStamp: Int!
    exchangeAddress: Bytes!
    tokenSymbol: String!
    userAddress: Bytes!
    ethAmount: BigInt!   # where negative means you sold eth to buy tokens
    tokenAmount: BigInt! # where negative means you sold tokens to buy eth
    fee: BigDecimal! # not !, because Add and Remove Liquidity don't have fee TODO - make it zero, instead of null
}