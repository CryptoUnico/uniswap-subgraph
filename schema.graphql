# Uniswap entity stores values from the Factory contract
type Uniswap @entity {
    id: ID! # Factory Address
    exchangeCount: Int!
    exchanges: [Exchange!]! @derivedFrom(field: "factoryID")

    totalVolumeInEth: BigDecimal!           # volume just on eth -i.e. we dont double count volume
    totalLiquidityInEth: BigDecimal!        # 2 * SUM(exchanges.ethLiquidity). Since tokenLiquiduity = ethLiquidity value, can just *2
    totalVolumeUSD: BigDecimal!             # Accumulate at each trade, not just calculated off whatever totalVolume is. making it more accurate as it is a live conversion
    totalLiquidityUSD: BigDecimal!

    totalTokenSells: BigInt!                # Total events where tokens have been sold
    totalTokenBuys: BigInt!                 # Total events where tokens have been bought
    totalAddLiquidity: BigInt!              # Total events where liqidity has been added
    totalRemoveLiquidity: BigInt!           # Total events where liquidity have been removed
}

type Exchange @entity {
    id: ID!                                 # Uniswap Exchange address
    tokenAddress: Bytes!                    # Token address
    tokenSymbol: String                     # Can't always get this, since any contract can be a uniswap contract (no erc20 interface)
    tokenName: String                       # Can't always get this, since any contract can be a uniswap contract (no erc20 interface)
    tokenDecimals: Int                      # Can't always get this, since any contract can be a uniswap contract (no erc20 interface)
    fee: BigDecimal!                        # Always 0.3% for v1 uniswap
    version: Int!                           # V1 only right now
    startTime: Int!                         # Time exchange was created
    endTime: Int                            # Time exchange is closed (such as an upgrade to uniswap contacts)

    ethLiquidity: BigDecimal!               # Equals the liquidty provided. Will likely be different than ethBalance
    tokenLiquidity: BigDecimal!             # Equals the token liquidity provided. Will likely be different thatn tokenBalance
    ethBalance: BigDecimal!                 # Equals the ether balance of the contract
    tokenBalance: BigDecimal!               # Equals the token balance of the contract
    combinedBalanceInEth: BigDecimal!       # Equal to ethBalance + (tokenBalance/price). Stored to simplify users calculating their own personal return. because the ratio may have changes a lot in one direction
    combinedBalanceInUSD: BigDecimal!       # Equal to combinedBalanceInUSD * DAI/ETH
    ROI: BigDecimal!                        # ROI for the exchanges lifetime.
    totalUniToken: BigDecimal!              # Count of the unilying unitokens that represent liquidity provided ownership

    # Counting Events
    addLiquidityCount: BigInt!              # Count the number of times liquidity has been added
    removeLiquidityCount: BigInt!           # Count the number of times liquidity has been removed
    sellTokenCount: BigInt!                 # Count the number of times the tokens been sold
    buyTokenCount: BigInt!                  # Count the number of times the tokens been bought

    # Price values using eth
    lastPrice: BigDecimal!                  # The last trade price
    price: BigDecimal!                      # Price is the total amount of tokens that equal one ETH. i.e. if ETH was 100 USD, price for DAI would be 100
    tradeVolumeToken: BigDecimal!           # Total tokens traded EVER
    tradeVolumeEth: BigDecimal!             # Total eth traded EVER
    totalValue: BigDecimal!                 # totalValue is accumulation of trade price * trade volume. i.e. TV = tokensSold * priceTokensSold
    weightedAvgPrice: BigDecimal!           # Avg price of all trades since inception. WAP = totalValue / totalVolume

    # Price values uing usd
    lastPriceUSD: BigDecimal!               # The last trade price in USD
    priceUSD: BigDecimal!                   # USD / token
    weightedAvgPriceUSD: BigDecimal!        # weightAvgPriceUSD = ( $1 of ETH in ETH ) / weightedAvgPrice

    # Fields used to help derived relationship
    factoryID: String!                                                              # used for @derivedFrom of Factory
    tokenHolders: [UserExchangeData!]! @derivedFrom(field: "exchangeAddress")       # Relationship to show all token holders on the exchange
    txs: [Transaction!]! @derivedFrom(field: "exchangeAddress")                     # Relationship to show all txs on the exchange
}

type User @entity {
    id: ID!                         # user eth adddress
    exchangeBalances: [UserExchangeData!]!  @derivedFrom(field: "userAddress")
    txs: [Transaction!]!  @derivedFrom(field: "userAddress")
}

type UserExchangeData @entity {
    id: ID!                         # ID is concatenation of token and user addr. i.e. 0xahiow4-0xkashkd34....
    userAddress: Bytes!             # used for @derivedFrom of User
    exchangeAddress: Bytes!         # used for @derivedFrom of TrackedExchange

    # Liquidity Provider Data
    ethDeposited: BigDecimal!       # where negative means eth was exchanged for tokens
    tokensDeposited: BigDecimal!    # Where negative means tokens were exchanged for eth
    ethWithdrawn: BigDecimal!
    tokensWithdrawn: BigDecimal!
    uniTokensMinted: BigDecimal!
    uniTokensBurned: BigDecimal!

    # Trading Data
    # Note - Fee is always charged in what the user is paying with. i.e. you buy eth by paying in token. Fee is in token
    ethBought: BigDecimal!
    ethSold: BigDecimal!
    tokensBought: BigDecimal!
    tokensSold: BigDecimal!
    ethFeesPaid: BigDecimal!
    tokenFeesPaid: BigDecimal!
    ethFeesInUSD: BigDecimal!
    tokenFeesInUSD: BigDecimal!
}

type Transaction @entity {
    id: ID!             # Transaction Hash
    event: String!
    block: Int!
    timeStamp: Int!
    exchangeAddress: Bytes!
    tokenAddress: Bytes!
    tokenSymbol: String
    userAddress: Bytes!
    ethAmount: BigInt!   # Trade Event: negative means sold eth. Liquidity Event: Negative = removed. Positive = added
    tokenAmount: BigInt! # Trade Event: negative means sold eth. Liquidity Event: Negative = removed. Positive = added
    fee: BigDecimal!
}